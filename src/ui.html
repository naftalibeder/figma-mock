<style type="text/css">
  html {
    font-family: Verdana, Geneva, Tahoma, sans-serif;
  }
  body {
    padding-left: 8px;
    padding-right: 8px;
  }
  h2 {
    font-size: 12;
    padding-top: 8px;
  }
  p, div, input, label, textarea {
    font-size: 11;
  }
  p.error {
    color: rgb(218, 80, 103);
  }
  .overlay {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 16px;
    background-color: white;
  }
  .buttons {
    display: inline-flex;
    flex-wrap: wrap;
    justify-content: space-between;
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 16px;
    gap: 16px;
  }
  button {
    flex: 1;
    height: 40px;
    font-size: 11;
    border-width: 0;
  }
  button:hover {
    background-color: rgb(221, 221, 221);
  }
  button.primary {
    background-color: rgb(98, 140, 255);
    color: white;
  }
  button.primary:hover {
    background-color: rgb(75, 112, 214);
  }
  button.link {
    background: none;
    border: none;
    padding: 0;
    color: rgb(75, 112, 214);
    text-decoration: underline;
    cursor: pointer;
  }
  select {
    width: 100%;
    padding: 8px;
  }
  textarea {
    resize: none;
    width: 100%;
    padding: 8px;
  }
  input.text {
    width: 100%;
    height: 40px;
    padding-left: 8px;
    padding-right: 8px;
    margin-bottom: 8px;
  }
  pre {
    font-family: monospace;
    background-color: rgb(231, 231, 231);
    word-wrap: break-word;
    padding: 16px;
  }
</style>

<body>
  <link rel="stylesheet" href="main.css" />

  <h2>Output</h2>
  <p>Choose the group of text fields to fill.</p>
  <select id="nodes-dropdown"></select>

  <h2>Input</h2>
  <p>Choose a type of data to paste into the selected fields.</p>
  <select id="input-dropdown" onchange="onChangeInputKind()"></select>
  <button id="settings-button" class='link'>Customize</button>

  <h2>Options</h2>
  <input id="randomize-checkbox" type="checkbox" checked='true'>
  <label for="randomize-checkbox">Randomize</label><br>
  <input id="capitalize-checkbox" type="checkbox">
  <label for="capitalize-checkbox">Capitalize first letter</label><br>

  <br>

  <div class='buttons'>
    <button id="cancel-button">Cancel</button>
    <button id="confirm-button" class='primary'>Paste</button>
  </div>

  <div id='settings-overlay' class='overlay'>
    <p>Add a url to a publicly available index.json file that follows the format below.</p>
    <pre>
{
  "name": "Household Objects",
  "lists": [
    {
      "name": "Tools",
      "path": "tools.txt"
    }
  ]
}</pre>    
    <textarea id="settings-textbox" class='text' type="text" rows="3" onblur="fetchInputs()" placeholder="Url to index.json file">https://raw.githubusercontent.com/naftalibeder/figma-mock-content/main/index.json</textarea>
    <p id="settings-error-label" class="error">Error fetching data from this url.</p>
    <div class='buttons'>
      <button id="settings-back-button">Back</button>
    </div>
  </div>
</body>

<script>
  const nodesDropdown = document.getElementById('nodes-dropdown');
  const inputDropdown = document.getElementById('input-dropdown');
  const randomizeCheckbox = document.getElementById('randomize-checkbox');
  const capitalizeCheckbox = document.getElementById('capitalize-checkbox');
  const settingsButton = document.getElementById('settings-button');
  const settingsOverlay = document.getElementById('settings-overlay');
  const settingsTextbox = document.getElementById('settings-textbox');
  const settingsErrorLabel = document.getElementById('settings-error-label');
  const settingsBackButton = document.getElementById('settings-back-button');
  const confirmButton = document.getElementById('confirm-button');
  const cancelButton = document.getElementById('cancel-button');

  settingsOverlay.hidden = true;

  onmessage = event => {
    const msg = event.data.pluginMessage;

    [...inputDropdown.children].forEach(child => inputDropdown.removeChild(child));
    [...nodesDropdown.children].forEach(child => nodesDropdown.removeChild(child));

    if (msg.type === 'init') {
      fetchInputs();

      const nodeGroups = msg.nodeGroups;
      nodeGroups.forEach((nodeGroup, i) => {
        const nodes = Object.values(nodeGroup.nodesMap);
        const nodeGroupTexts = [...new Set(nodes.map(o => o.characters.slice(0, 20)))];
        const fieldCountDisplay = `(${nodeGroupTexts.length} fields)`;
        const nodesDisplayText = `${nodeGroupTexts[0]}${nodeGroupTexts.length > 1 ? ', ...' : ''}${nodeGroupTexts.length > 1 ? ' ' + fieldCountDisplay : ''}`;
        // const nodesDisplayText = nodeGroupTexts.slice(0, 3).join(', ');

        const nodeOption = document.createElement('option');
        nodeOption.value = nodeGroup.key;
        nodeOption.innerHTML = nodesDisplayText;
        if (i === 0) nodeOption.selected = true;
        nodesDropdown.appendChild(nodeOption);
      });

      confirmButton.disabled = false;
    } else if (msg.type === 'clear') {
      [...inputDropdown.children].forEach(child => inputDropdown.removeChild(child));
      [...nodesDropdown.children].forEach(child => nodesDropdown.removeChild(child));
      confirmButton.disabled = true;
    }
  };

  function fetchInputs() {
    [...inputDropdown.children].forEach(child => inputDropdown.removeChild(child));

    const baseUrl = settingsTextbox.value.replace('/index.json', '');
    fetch(`${baseUrl}/index.json`, (response, error) => {
      let lists = null;

      try {
        lists = JSON.parse(response).lists;
        settingsErrorLabel.hidden = true;
      } catch (error) {
        console.log(`Error: ${error}`);
        settingsErrorLabel.hidden = false;
      }

      if (!lists) return;

      lists.forEach((list, index) => {
        const inputOption = document.createElement('option');
        inputOption.id = `input-option-${index}`;
        inputOption.innerHTML = list.name;
        inputOption.dataset.url = list.path ? `${baseUrl}/${list.path}` : list.url;
        inputDropdown.appendChild(inputOption);
      });

      console.log(`Fetched ${lists.length} input lists`);
    });
  }

  confirmButton.onclick = () => {
    const selectedInputDropdownOption = [...inputDropdown.children].filter(o => o.selected == true)[0];
    const selectedNodeDropdownOption = [...nodesDropdown.children].filter(o => o.selected == true)[0];
    const randomize = randomizeCheckbox.checked;
    const capitalize = capitalizeCheckbox.checked;

    console.log('Selected:', selectedInputDropdownOption.id);

    const config = {
      type: 'confirm',
      items: [],
      groupingKey: selectedNodeDropdownOption.value,
      randomize,
      capitalize,
    };

    const inputUrl = selectedInputDropdownOption.dataset.url;
    if (inputUrl) {
      console.log('Fetching:', inputUrl);
      fetch(inputUrl, (response) => {
        const items = itemsFromStr(response);
        parent.postMessage({ pluginMessage: { ...config, items } }, '*');
      });
    }
  };

  cancelButton.onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
  };

  settingsButton.onclick = () => {
    settingsOverlay.hidden = false;
  };

  settingsBackButton.onclick = () => {
    settingsOverlay.hidden = true;
  };

  function fetch(url, onResponse, onError) {
    let request = new XMLHttpRequest();
    request.open('GET', url);
    request.responseType = 'text';
    request.onload = () => onResponse(request.response);
    request.onerror = onError;
    request.send();
  }

  function itemsFromStr(str) {
    return str.split('\n').filter(line => line.length > 0);
  }

  parent.postMessage({ pluginMessage: { type: 'init' } }, '*');
</script>