<style type="text/css">
  html {
    font-family: Verdana, Geneva, Tahoma, sans-serif;
  }
  body {
    padding-left: 8px;
    padding-right: 8px;
  }
  h2 {
    font-size: 12;
    padding-top: 8px;
  }
  p, div, input, label, textarea {
    font-size: 11;
  }
  p.error {
    color: rgb(218, 80, 103);
  }
  p.meta {
    font-size: 9;
    color: rgb(83, 83, 83);
  }
  .overlay {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    padding-left: 16px;
    padding-right: 16px;
    background-color: white;
  }
  .buttons {
    display: inline-flex;
    flex-wrap: wrap;
    justify-content: space-between;
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 16px;
    gap: 8px;
    background-color: white;
  }
  button {
    flex: 1;
    height: 40px;
    border-radius: 2px;
    font-size: 11;
    border-width: 0;
  }
  button:hover {
    background-color: rgb(221, 221, 221);
  }
  button.primary {
    background-color: rgb(98, 140, 255);
    color: white;
  }
  button.primary:hover {
    background-color: rgb(75, 112, 214);
  }
  button.link {
    background: none;
    border: none;
    height: auto;
    padding: 0;
    color: rgb(75, 112, 214);
    text-decoration: underline;
    cursor: pointer;
  }
  button.link:hover {
    color: rgb(108, 144, 245);
  }
  button:disabled {
    background-color: lightgray;
    color: gray;
  }
  button:disabled:hover {
    background-color: lightgray;
    color: gray;
  }
  select {
    width: 100%;
    padding: 8px;
  }
  textarea {
    resize: none;
    width: 100%;
    padding: 8px;
  }
  .vertical-list {
    display: flex;
    flex: 1;
    flex-direction: column;
    gap: 8px;
  }
  .vertical-list-item {
    flex: 1;
  }
  .horizontal-list {
    display: flex;
    flex-wrap: nowrap;
    box-sizing: border-box;
    justify-content: space-between;
    gap: 4px;
  }
  .horizontal-list-item {
    width: 100%;
  }
  .vertical-item-and-text {
    display: flex;
    flex-wrap: nowrap;
    box-sizing: border-box;
    justify-content: space-between;
    flex-direction: column;
    gap: 8px;
  }
  .horizontal-item-and-text {
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: flex-start;
    justify-content: center;
  }
  input[type=checkbox] {
    width: 14;
    height: 14;
  }
  input[type=text] {
    height: 40px;
    width: 100%;
    padding: 8px;
  }
  input[type=number] {
    height: 40px;
    width: 100%;
    padding: 8px;
  }
  input[type=date] {
    height: 40px;
    width: 100%;
  }
  input:hover, select:hover {
    background-color: rgb(252, 252, 252);
  }
  pre {
    font-family: monospace;
    background-color: rgb(231, 231, 231);
    overflow-x: scroll;
    overflow-y: hidden;
    padding: 16px;
    border-radius: 2px;
  }
  .margin-above {
    margin-top: 8px;
  }
</style>

<body>
  <div style="padding-bottom: 60px;">
    <h2>Output</h2>
    <p>Choose the group of text fields to fill.</p>
    <select id="nodes-dropdown"></select>

    <h2>Input</h2>
    <p>Choose a type of data to paste. <button id="settings-button" class='link'>Edit lists</button></p>
    <select id="input-dropdown"></select>

    <h2 id="type-options-title">Options</h2>
    <div id='options-section-strings'>
      <p>Capitalization</p>
      <select id="casing-dropdown">
        <option value="none">Use original</option>
        <option value="sentence">Sentence case</option>
        <option value="title">Title case</option>
        <option value="upper">Upper case</option>
        <option value="lower">Lower case</option>
      </select>
    </div>
    <div id='options-section-numbers'>
      <div class='horizontal-list'>
        <div class="horizontal-list-item vertical-item-and-text">
          <label for="min-number-input">Min</label>
          <input id="min-number-input" type="number" value="0" />
        </div>
        <div class="horizontal-list-item vertical-item-and-text">
          <label for="max-number-input">Max</label>
          <input id="max-number-input" type="number" value="100" />
        </div>
        <div class="horizontal-list-item vertical-item-and-text">
          <label for="precision-number-input">Decimals</label>
          <input id="precision-number-input" type="number" value="0" min="0" max="100" />
        </div>
      </div>
    </div>
    <div id='options-section-dates'>
      <div class='horizontal-list'>
        <div class="horizontal-list-item vertical-item-and-text">
          <label for="min-date-input">Earliest</label>
          <input id="min-date-input" type="date" value="2021-01-01" />
        </div>
        <div class="horizontal-list-item vertical-item-and-text">
          <label for="max-date-input">Latest</label>
          <input id="max-date-input" type="date" value="2021-12-31" />
        </div>
      </div>
      <div class="horizontal-list-item vertical-item-and-text margin-above">
        <label for="format-date-input">Format</label>
        <input id="format-date-input" type="text" placeholder="MM/DD/YYYY" value="MM/DD/YYYY" />
      </div>
      <p class="meta">DD = 31; dddd = Monday; ddd = Mon; mmmm = January; mmm = Jan; MM = 1; YYYY = 2021</p>
    </div>

    <h2>Other options</h2>
    <p>Order</p>
    <select id="order-dropdown">
      <option value="random" selected="true">Random</option>
      <option value="ascending">Ascending</option>
      <option value="descending">Descending</option>
    </select>
    <div id='options-section-concat' class='margin-above'>
      <div class='horizontal-list'>
        <div class="horizontal-list-item vertical-item-and-text">
          <label for="prepend-input">Prepend with</label>
          <input id="prepend-input" type="text" placeholder="Optional text" />
        </div>
        <div class="horizontal-list-item vertical-item-and-text">
          <label for="append-input">Append with</label>
          <input id="append-input" type="text" placeholder="Optional text" />
        </div>
      </div>
    </div>
  </div>

  <br>

  <div class='buttons'>
    <button id="cancel-button">Cancel</button>
    <button id="confirm-button" class='primary'>Paste</button>
  </div>

  <div id='settings-overlay' class='overlay'>
    <h2>Urls</h2>
    <div id='settings-urls-list' class='vertical-list'></div>
    <p id="settings-error-label" class="error">Error fetching data from this url.</p>

    <h2>Rules</h2>
    <p>Each JSON file listed above must follow this format:</p>
    <pre id='settings-index-code-example'></pre>

    <div class='buttons'>
      <button id="settings-back-button">Back</button>
    </div>
  </div>
</body>

<script>
  const nodesDropdown = document.getElementById('nodes-dropdown');
  const inputDropdown = document.getElementById('input-dropdown');

  const typeOptionsTitle = document.getElementById('type-options-title');
  const optionsSectionStrings = document.getElementById('options-section-strings');
  const optionsSectionNumbers = document.getElementById('options-section-numbers');
  const optionsSectionDates = document.getElementById('options-section-dates');
  
  const casingDropdown = document.getElementById('casing-dropdown');
  
  const minNumberInput = document.getElementById('min-number-input');
  const maxNumberInput = document.getElementById('max-number-input');
  const precisionNumberInput = document.getElementById('precision-number-input');
  
  const minDateInput = document.getElementById('min-date-input');
  const maxDateInput = document.getElementById('max-date-input');
  const formatDateInput = document.getElementById('format-date-input');
  
  const orderDropdown = document.getElementById('order-dropdown');
  const prependInput = document.getElementById('prepend-input');
  const appendInput = document.getElementById('append-input');
  
  const settingsButton = document.getElementById('settings-button');
  const settingsOverlay = document.getElementById('settings-overlay');
  const settingsUrlsList = document.getElementById('settings-urls-list');
  const settingsErrorLabel = document.getElementById('settings-error-label');
  const settingsIndexCodeExample = document.getElementById('settings-index-code-example');
  const settingsBackButton = document.getElementById('settings-back-button');

  const confirmButton = document.getElementById('confirm-button');
  const cancelButton = document.getElementById('cancel-button');

  settingsOverlay.hidden = true;
  confirmButton.disabled = true;

  settingsIndexCodeExample.innerHTML = `{
  "name": "Coffee",
  "lists": [
    {
      "name": "Bean Types",
      "url": "https://public.coffee/bean-types.txt"
    }
    {
      "name": "Roasts",
      "path": "roasts.txt"
    }
  ]
}`;

  onmessage = event => {
    const message = event.data.pluginMessage;
    const { type } = message;

    if (type === 'init') {
      console.log('------');

      clearInputOptionSections();
      clearNodeGroupElements();
      clearSettingsUrlElements();

      const { url, nodeGroups } = message;
      let urls = ['https://raw.githubusercontent.com/naftalibeder/figma-mock-content/main/index.json'];
      if (url) urls.push(url);

      createSettingsUrlElements(urls);
      fetchAndCreateInputElements(urls);
      createNodeGroupElements(nodeGroups);

      inputDropdown.onchange = onInputDropdownChange;
      onInputDropdownChange();

      confirmButton.disabled = nodeGroups.length === 0;
    }
  };

  const createSettingsUrlElements = (urls) => {
    let urlsCopy = [...urls];
    if (urlsCopy.length === 1) urlsCopy.push(null);

    console.log(`Creating settings url elements from: [${urlsCopy}]`);

    urlsCopy.forEach((url, index) => {
      const urlWrap = document.createElement('div');
      urlWrap.className = 'horizontal-item-and-text';
      settingsUrlsList.appendChild(urlWrap);

      const urlTextField = document.createElement('input');
      urlTextField.type = 'text';
      urlTextField.placeholder = "https://mysite.com/index.json";
      urlTextField.value = url;
      urlTextField.onblur = () => {
        parent.postMessage({ pluginMessage: { type: 'url', url: urlTextField.value } }, '*');
        urlsCopy[index] = urlTextField.value;
        fetchAndCreateInputElements(urlsCopy);
      };
      if (index === 0) urlTextField.disabled = true;
      urlWrap.appendChild(urlTextField);
    });
  }

  const fetchAndCreateInputElements = (urls) => {
    console.log(`Fetching from all urls: [${urls}]`);

    clearInputOptionSections();
    createLoadingInputElement();

    let responses = []; // { baseUrl, name, lists, error }

    const next = (i) => {
      fetchInputs(urls[i], i, (response) => {
        responses.push(response);
        if (i < urls.length - 1) {
          next(i + 1);
        } else {
          clearInputOptionSections();
          for (let i = 0; i < responses.length; i++) {
            const response = responses[i];
            createInputElements(response);
          }
        }
      });
    };

    next(0);
  }

  const fetchInputs = (url, index, onResponse) => {
    const baseUrl = url.replace('/index.json', '');

    if (!url || url.length === 0) {
      onResponse?.({ baseUrl });
      return;
    }

    console.log(`Fetching from ${url} at index ${index}`);

    fetch(url, (response, error) => {
      try {
        response = JSON.parse(response);
        const { name, lists } = response;
        console.log(`Fetched ${lists.length} lists from ${url}`);
        settingsErrorLabel.hidden = true;
        if (error) throw error;
        onResponse?.({ baseUrl, ...response, error });
      } catch (error) {
        console.log(`Error: ${error}`);
        onResponse?.({ baseUrl, error });
      }
    });
  }

  const createLoadingInputElement = (response) => {
    const inputOption = document.createElement('option');
    inputOption.innerHTML = 'Loading...';
    inputDropdown.appendChild(inputOption);
  }

  const createInputElements = (response) => {
    const { baseUrl, name: sectionName, lists, error } = response;

    if (error) {
      settingsErrorLabel.hidden = false;
      return;
    }
    
    if (!sectionName || !lists) return;

    console.log(`Creating input elements from ${sectionName} (${baseUrl})`);

    const inputOptionGroup = document.createElement('optgroup');
    inputOptionGroup.label = sectionName;
    inputDropdown.appendChild(inputOptionGroup);

    lists.forEach((list, index) => {
      const { name, path, url, type } = list;

      const inputOption = document.createElement('option');
      inputOption.id = slugify(name);
      inputOption.innerHTML = name;
      inputOption.dataset.url = path ? `${baseUrl}/${path}` : url ? url : '';
      inputOption.dataset.type = type ?? 'strings';
      inputOptionGroup.appendChild(inputOption);
    });
  }

  const createEmptyNodeGroupElement = () => {
    const nodeOption = document.createElement('option');
    nodeOption.innerHTML = 'No items selected';
    nodesDropdown.appendChild(nodeOption);
  };

  const createNodeGroupElements = (nodeGroups) => {
    if (nodeGroups.length === 0) {
      clearNodeGroupElements();
      createEmptyNodeGroupElement();

      nodesDropdown.disabled = true;
    } else {
      nodeGroups.forEach((nodeGroup, i) => {
        const nodes = Object.values(nodeGroup.nodesMap);
        const nodeGroupTexts = [...new Set(nodes.map(o => o.characters))];
        const fieldCountDisplay = `(${nodes.length} fields)`;
        const multipleTextValues = nodeGroupTexts.length > 1;
        
        let nodesDisplayText = '';
        if (multipleTextValues) {
          nodesDisplayText = `${nodeGroupTexts[0].slice(0, 12)}, ${nodeGroupTexts[1].slice(0, 12)}, ... ${fieldCountDisplay}`;
        } else {
          nodesDisplayText = `${nodeGroupTexts[0].slice(0, 30)} ${fieldCountDisplay}`;
        }

        const nodeOption = document.createElement('option');
        nodeOption.value = nodeGroup.key;
        nodeOption.innerHTML = nodesDisplayText;
        nodeOption.dataset.nodeCount = nodeGroup.count;
        if (i === 0) nodeOption.selected = true;
        nodesDropdown.appendChild(nodeOption);
      });

      nodesDropdown.disabled = false;
    }
  }
  
  const onInputDropdownChange = (event) => {
    optionsSectionStrings.hidden = true;
    optionsSectionNumbers.hidden = true;
    optionsSectionDates.hidden = true;
    
    if (!event) {
      typeOptionsTitle.innerHTML = `Text options`;
      optionsSectionStrings.hidden = false;
      return;
    }
    
    const type = event.target.options[event.target.selectedIndex].dataset.type;
    console.log(`Changed input: ${type}`);

    if (type === 'strings') {
      typeOptionsTitle.innerHTML = `Text options`;
      optionsSectionStrings.hidden = false;
    } else if (type === 'numbers') {
      typeOptionsTitle.innerHTML = `Number options`;
      optionsSectionNumbers.hidden = false;
    } else if (type === 'dates') {
      typeOptionsTitle.innerHTML = `Date options`;
      optionsSectionDates.hidden = false;
    }
  }

  confirmButton.onclick = () => {
    const selectedInputDropdownOption = inputOptions().filter(o => o.selected == true)[0];
    const selectedNodeDropdownOption = [...nodesDropdown.children].filter(o => o.selected == true)[0];
    
    const order = [...orderDropdown.children].filter(o => o.selected == true)[0].value;
    const casing = casingDropdown.value;
    const prepend = prependInput.value;
    const append = appendInput.value;

    const inputUrl = selectedInputDropdownOption.dataset.url;
    const inputType = selectedInputDropdownOption.dataset.type;
    const nodeCount = selectedNodeDropdownOption.dataset.nodeCount;

    console.log(`Selected ${selectedInputDropdownOption.id}, casing ${casing}, order ${order}, count ${nodeCount}`);

    const config = {
      type: 'confirm',
      items: [],
      groupingKey: selectedNodeDropdownOption.value,
      casing,
      prepend,
      append,
    };

    if (inputUrl.length > 0) {
      console.log('Fetching:', inputUrl);
      fetch(inputUrl, (response, error) => {
        let items = itemsFromStr(response);
        items = ordered(items, order);
        parent.postMessage({ pluginMessage: { ...config, items } }, '*');
      });
    } else if (inputType === 'numbers') {
      let items = [];
      for (let i = 0; i < nodeCount; i++) {
        items.push(`${randomNumberString(minNumberInput.value, maxNumberInput.value, precisionNumberInput.value)}`);
      }
      items = ordered(items, order);
      parent.postMessage({ pluginMessage: { ...config, items } }, '*');
    } else if (inputType === 'dates') {
      let items = [];
      const minDate = new Date(minDateInput.value).getTime();
      const maxDate = new Date(maxDateInput.value).getTime();
      const format = formatDateInput.value;
      for (let i = 0; i < nodeCount; i++) {
        items.push(`${randomDateString(minDate, maxDate, format)}`);
      }
      // TODO: Order dates _before_ stringifying.
      items = ordered(items, order);
      parent.postMessage({ pluginMessage: { ...config, items } }, '*');
    }
  };

  cancelButton.onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
  };

  settingsButton.onclick = () => {
    settingsOverlay.hidden = false;
  };

  settingsBackButton.onclick = () => {
    settingsOverlay.hidden = true;
  };

  const fetch = (url, onResponse) => {
    let request = new XMLHttpRequest();
    try {
      request.open('GET', url);
      request.responseType = 'text';
      request.onload = () => onResponse(request.response);
      request.onerror = (error) => onResponse(null, error);
      request.send();
    } catch (error) {
      onResponse(null, error)
    }
  }

  const itemsFromStr = (str) => {
    return str.split('\n').filter(line => line.length > 0);
  }

  const inputOptions = () => {
    let o = [];
    for (let i = 0; i < inputDropdown.children.length; i++) {
      const section = inputDropdown.children[i];
      for (let i = 0; i < section.children.length; i++) {
        const option = section.children[i];
        o.push(option);
      }
    }
    return o;
  }

  const clearInputOptionSections = () => {
    while (inputDropdown.firstChild) {
      inputDropdown.removeChild(inputDropdown.firstChild);
    }
  }

  const clearNodeGroupElements = () => {
    while (nodesDropdown.firstChild) {
      nodesDropdown.removeChild(nodesDropdown.firstChild);
    }
  }

  const clearSettingsUrlElements = () => {
    while (settingsUrlsList.firstChild) {
      settingsUrlsList.removeChild(settingsUrlsList.firstChild);
    }
  }

  const randomNumberString = (min, max, precision) => {
    min = parseFloat(min);
    max = parseFloat(max);
    precision = parseFloat(precision);
    const randNum = min + Math.random() * (max - min);
    return randNum.toFixed(precision);
  }

  const randomDateString = (min, max, format) => {
    const randDate = new Date(min + Math.random() * (max - min));
    return format
    .replace('DD', randDate.getDate())
    .replace('dddd', randDate.toLocaleString("default", { weekday: "long" }))
    .replace('ddd', randDate.toLocaleString("default", { weekday: "short" }))
    .replace('mmmm', randDate.toLocaleString("default", { month: "long" }))
    .replace('mmm', randDate.toLocaleString("default", { month: "short" }))
    .replace('MM', randDate.getMonth() + 1)
    .replace('YYYY', randDate.getFullYear());
  }

  const ordered = (items, rule) => {
    console.log(`Ordering ${items.length} items with ${rule} rule`);

    if (rule === 'random') {
      const unrandomized = [...items];
      const randomized = [];
      while (unrandomized.length > 0) {
        const item = unrandomized.splice(Math.floor(Math.random() * unrandomized.length), 1)[0];
        randomized.push(item);
      }
      return randomized;
    } else if (rule === 'ascending') {
      return items.sort((a, b) => a - b);
    } else if (rule === 'descending') {
      return items.sort((a, b) => b - a);
    } else {
      return items;
    }
  }

  const slugify = (text) => {
    return text.replace(' ', '-').toLowerCase();
  }

  parent.postMessage({ pluginMessage: { type: 'init' } }, '*');
</script>