<style type="text/css">
  html {
    font-family: Verdana, Geneva, Tahoma, sans-serif;
  }
  body {
    padding-left: 8px;
    padding-right: 8px;
  }
  h2 {
    font-size: 12;
    padding-top: 8px;
  }
  p, div, input, label, textarea {
    font-size: 11;
  }
  p.error {
    color: rgb(218, 80, 103);
  }
  .overlay {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 16px;
    background-color: white;
  }
  .buttons {
    display: inline-flex;
    flex-wrap: wrap;
    justify-content: space-between;
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 16px;
    gap: 16px;
  }
  button {
    flex: 1;
    height: 40px;
    font-size: 11;
    border-width: 0;
  }
  button:hover {
    background-color: rgb(221, 221, 221);
  }
  button.primary {
    background-color: rgb(98, 140, 255);
    color: white;
  }
  button.primary:hover {
    background-color: rgb(75, 112, 214);
  }
  button.link {
    background: none;
    border: none;
    height: auto;
    color: rgb(75, 112, 214);
    text-decoration: underline;
    cursor: pointer;
  }
  button:disabled {
    background-color: lightgray;
    color: gray;
  }
  select {
    width: 100%;
    padding: 8px;
  }
  textarea {
    resize: none;
    width: 100%;
    padding: 8px;
  }
  input.text {
    width: 100%;
    height: 40px;
    padding-left: 8px;
    padding-right: 8px;
    margin-bottom: 8px;
  }
  pre {
    font-family: monospace;
    background-color: rgb(231, 231, 231);
    overflow-x: scroll;
    overflow-y: hidden;
    padding: 16px;
  }
  .margin-above {
    margin-top: 8px;
  }
</style>

<body>
  <h2>Output</h2>
  <p>Choose the group of text fields to fill.</p>
  <select id="nodes-dropdown"></select>

  <h2>Input</h2>
  <p>Choose a type of data to paste into the selected fields.</p>
  <select id="input-dropdown"></select>
  <button id="settings-button" class='link margin-above'>Customize</button>

  <h2>Options</h2>
  <p>Capitalization</p>
  <select id="casing-dropdown">
    <option value="none">Use original</option>
    <option value="sentence">Sentence case</option>
    <option value="title">Title case</option>
    <option value="upper">Upper case</option>
    <option value="lower">Lower case</option>
  </select>
  <div class='margin-above'>
    <input id="randomize-checkbox" type="checkbox" checked='true'>
    <label for="randomize-checkbox">Randomize</label><br>
  </div>

  <br>

  <div class='buttons'>
    <button id="cancel-button">Cancel</button>
    <button id="confirm-button" class='primary'>Paste</button>
  </div>

  <div id='settings-overlay' class='overlay'>
    <p>Add a url to a publicly available index.json file that follows the format below.</p>
    <pre>
{
  "name": "Household Objects",
  "lists": [
    {
      "name": "Animals",
      "url": "https://raw.githubusercontent.com/verachell/English-word-lists-miscellaneous-categories/main/wordlists/Animals.txt"
    }
  ]
}</pre>    
    <textarea id="settings-textbox" class='text' type="text" rows="3" onblur="fetchInputs()" placeholder="Url to index.json file"></textarea>
    <p id="settings-error-label" class="error">Error fetching data from this url.</p>
    <button id="settings-restore-button" class='link margin-above' onclick="restoreDefaultInputOptions()">Restore default url</button>

    <div class='buttons'>
      <button id="settings-back-button">Back</button>
    </div>
  </div>
</body>

<script>
  const nodesDropdown = document.getElementById('nodes-dropdown');
  const inputDropdown = document.getElementById('input-dropdown');
  const randomizeCheckbox = document.getElementById('randomize-checkbox');
  const casingDropdown = document.getElementById('casing-dropdown');
  const settingsButton = document.getElementById('settings-button');
  const settingsOverlay = document.getElementById('settings-overlay');
  const settingsTextbox = document.getElementById('settings-textbox');
  const settingsErrorLabel = document.getElementById('settings-error-label');
  const settingsBackButton = document.getElementById('settings-back-button');
  const confirmButton = document.getElementById('confirm-button');
  const cancelButton = document.getElementById('cancel-button');

  settingsOverlay.hidden = true;
  confirmButton.disabled = true;

  onmessage = event => {
    const msg = event.data.pluginMessage;

    clearInputOptions();
    clearNodeOptions();

    if (msg.type === 'init') {
      if (msg.url) {
        settingsTextbox.innerHTML = msg.url;
      } else {
        settingsTextbox.innerHTML = 'https://raw.githubusercontent.com/naftalibeder/figma-mock-content/main/index.json';
      }

      fetchInputs();

      const nodeGroups = msg.nodeGroups;
      nodeGroups.forEach((nodeGroup, i) => {
        const nodes = Object.values(nodeGroup.nodesMap);
        const nodeGroupTexts = [...new Set(nodes.map(o => o.characters.slice(0, 30)))];
        const fieldCountDisplay = `(${nodeGroupTexts.length} fields)`;
        const nodesDisplayText = `${nodeGroupTexts[0]}${nodeGroupTexts.length > 1 ? ', ...' : ''}${nodeGroupTexts.length > 1 ? ' ' + fieldCountDisplay : ''}`;
        // const nodesDisplayText = nodeGroupTexts.slice(0, 3).join(', ');

        const nodeOption = document.createElement('option');
        nodeOption.value = nodeGroup.key;
        nodeOption.innerHTML = nodesDisplayText;
        if (i === 0) nodeOption.selected = true;
        nodesDropdown.appendChild(nodeOption);
      });

      if (nodeGroups.length > 0) {
        confirmButton.disabled = false;
      }
    } else if (msg.type === 'clear') {
      clearInputOptions();
      clearNodeOptions();
      confirmButton.disabled = true;
    }
  };

  const fetchInputs = () => {
    clearInputOptions();

    const baseUrl = settingsTextbox.value.replace('/index.json', '');
    const url = `${baseUrl}/index.json`;
    fetch(url, (response, error) => {
      try {
        response = JSON.parse(response);
        settingsErrorLabel.hidden = true;
        parent.postMessage({ pluginMessage: { type: 'url', url } }, '*');
      } catch (error) {
        console.log(`Error: ${error}`);
        settingsErrorLabel.hidden = false;
        return;
      }

      const { lists, name } = response;
      
      const inputOptionGroup = document.createElement('optgroup');
      inputOptionGroup.label = name;
      inputDropdown.appendChild(inputOptionGroup);

      lists.forEach((list, index) => {
        const inputOption = document.createElement('option');
        inputOption.id = slugify(list.name);
        inputOption.innerHTML = list.name;
        inputOption.dataset.url = list.path ? `${baseUrl}/${list.path}` : list.url;
        inputOptionGroup.appendChild(inputOption);
      });

      console.log(`Fetched ${lists.length} input lists`);
    });
  }

  confirmButton.onclick = () => {
    const selectedInputDropdownOption = inputOptions().filter(o => o.selected == true)[0];
    const selectedNodeDropdownOption = [...nodesDropdown.children].filter(o => o.selected == true)[0];
    const randomize = randomizeCheckbox.checked;
    const casing = casingDropdown.value;

    console.log(`Selected: ${selectedInputDropdownOption.id} with casing ${casing}`);

    const config = {
      type: 'confirm',
      items: [],
      groupingKey: selectedNodeDropdownOption.value,
      randomize,
      casing,
    };

    const inputUrl = selectedInputDropdownOption.dataset.url;
    if (inputUrl) {
      console.log('Fetching:', inputUrl);
      fetch(inputUrl, (response) => {
        const items = itemsFromStr(response);
        parent.postMessage({ pluginMessage: { ...config, items } }, '*');
      });
    }
  };

  cancelButton.onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
  };

  settingsButton.onclick = () => {
    settingsOverlay.hidden = false;
  };

  settingsBackButton.onclick = () => {
    settingsOverlay.hidden = true;
  };

  const fetch = (url, onResponse, onError) => {
    let request = new XMLHttpRequest();
    request.open('GET', url);
    request.responseType = 'text';
    request.onload = () => onResponse(request.response);
    request.onerror = onError;
    request.send();
  }

  const itemsFromStr = (str) => {
    return str.split('\n').filter(line => line.length > 0);
  }

  const inputOptions = () => {
    let o = [];
    for (let i = 0; i < inputDropdown.children.length; i++) {
      const section = inputDropdown.children[i];
      for (let i = 0; i < section.children.length; i++) {
        const option = section.children[i];
        o.push(option);
      }
    }
    return o;
  }

  const clearInputOptions = () => {
    for (let i = 0; i < inputDropdown.children.length; i++) {
      const section = inputDropdown.children[i];
      inputDropdown.removeChild(section);
    }
  }

  const clearNodeOptions = () => {
    for (let i = 0; i < nodesDropdown.children.length; i++) {
      const node = nodesDropdown.children[i];
      nodesDropdown.removeChild(node);
    }
  }

  const restoreDefaultInputOptions = () => {
    settingsTextbox.innerHTML = 'https://raw.githubusercontent.com/naftalibeder/figma-mock-content/main/index.json';
    fetchInputs();
  }

  const slugify = (text) => {
    return text.replace(' ', '-').toLowerCase();
  }

  parent.postMessage({ pluginMessage: { type: 'init' } }, '*');
</script>